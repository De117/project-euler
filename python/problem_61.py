# Problem 61 (Cyclical Figurate Numbers)
# ======================================
#
# Triangle, square, pentagonal, hexagonal, heptagonal, and octagonal
# numbers are all figurate (polygonal) numbers and are generated by the
# following formulae:
#
#     Triangle:   P_{3,n} = n(n+1)/2    1,3,6,10,15,...
#     Square:     P_{4,n} = n**2        1,4,9,16,25,...
#     Pentagonal: P_{5,n} = n(3n-1)/2   1,5,12,22,35,...
#     Hexagonal:  P_{6,n} = n(2n-1)     1,6,15,28,45,...
#     Heptagonal: P_{7,n} = n(5n-3)/2   1,7,18,34,55,...
#     Octagonal:  P_{8,n} = n(3n-2)     1,8,21,40,65,...
#
# The ordered set of three 4-digit numbers: 8128, 2882, 8281,
# has three interesting properties.
#
# The set is cyclic, in that the last two digits of each number is the first
# two digits of the next number (including the last number with the first).
# Each polygonal type: triangle (P_{3,127} = 8128), square (P_{4,91} = 8281),
# and pentagonal (P_{5,44} = 2882), is represented by a different number in
# the set.
#
# This is the only set of 4-digit numbers with this property.
#
# Find the sum of the only ordered set of six cyclic 4-digit numbers for
# which each polygonal type: triangle, square, pentagonal, hexagonal,
# heptagonal, and octagonal, is represented by a different number in
# the set.
import itertools

try:
    pairwise = itertools.pairwise
except AttributeError:
    def pairwise(l):
        iterator = iter(l)
        try:
            a = None
            b = next(iterator)  # if iterable was empty, a StopIteration is raised
            while True:
                a, b = b, next(iterator)
                yield (a, b)
        except StopIteration:
            return

def is_cyclic(number_set: list[int]) -> bool:
    for a, b in pairwise(number_set):
        if str(a)[-2:] != str(b)[:2]:
            return False

    a = number_set[-1]
    b = number_set[0]
    return str(a)[-2:] == str(b)[:2]

from problem_45 import triangular, pentagonal, hexagonal
from problem_45 import is_triangular, is_pentagonal, is_hexagonal

def square(n: int):  # n >= 0
    return n ** 2

def heptagonal(n: int):  # n >= 0
    return n*(5*n - 3)//2

def octagonal(n: int):  # n >= 0
    return n*(3*n - 2)

def is_square(n: int):
    origin = n**0.5
    rounded = round(origin)
    return abs(origin - rounded) < 1e-14

def is_heptagonal(n: int):
    origin = (3 + (9 + 40*n)**0.5) / 10
    rounded = round(origin)
    return abs(origin - rounded) < 1e-14

def is_octagonal(n: int):
    origin = (1 + (1 + 3*n)**0.5) / 3
    rounded = round(origin)
    return abs(origin - rounded) < 1e-14

four_digit_numbers = {
    3: [triangular(n) for n in range(10_000) if 1000 <= triangular(n) < 10_000],
    4: [square    (n) for n in range(10_000) if 1000 <= square    (n) < 10_000],
    5: [pentagonal(n) for n in range(10_000) if 1000 <= pentagonal(n) < 10_000],
    6: [hexagonal (n) for n in range(10_000) if 1000 <= hexagonal (n) < 10_000],
    7: [heptagonal(n) for n in range(10_000) if 1000 <= heptagonal(n) < 10_000],
    8: [octagonal (n) for n in range(10_000) if 1000 <= octagonal (n) < 10_000],
}
# About 30 billion combinations (=sets).
# And that doesn't cover the (6! = 720) possible permutations of each set.

# The given example is easy enough to find by brute force, as we have
#  96*68*56 = 365_568 sets, each with 3! permutations: at most 2_193_408 checks.

# try:
#     for n3 in four_digit_numbers[3]:
#         for n4 in four_digit_numbers[4]:
#             for n5 in four_digit_numbers[5]:
#                 for permutation in itertools.permutations([n3, n4, n5]):
#                     if is_cyclic(permutation):
#                         print(permutation)
#                         raise RuntimeError("break")
# except RuntimeError:
#     pass

# But we cannot do that here. We'll have to be constructive.
#
# Two numbers a and b form a "link" if the last
# two digits of a are the first two digits of b.
#
# We can build up all possible a---b links (for a and b of different types),
# and then use those 2-number subchains to form bigger subchains, and so on
# until we get to 6-number subchains.
#
# Then, we only need to find which 6-number subchain can be closed.
# (Note that the "can be closed" property doesn't generally hold for subchains.)
#
# Gee, this really looks like problem 60. :D

from dataclasses import dataclass

@dataclass
class Number:
    kind: int  # 3-8 denote triangular-octagonal
    value: int

@dataclass
class Chain:
    numbers: list[Number]

    def as_set(self) -> frozenset[int]:
        return frozenset([n.value for n in self.numbers])

    def kinds(self) -> frozenset[int]:
        return frozenset([n.kind for n in self.numbers])

def can_link(c1: Chain, c2: Chain, check_kinds=True) -> bool:
    a = c1.numbers[-1].value
    b = c2.numbers[0].value
    if str(a)[-2:] != str(b)[:2]:
        return False
    if check_kinds and c1.kinds() & c2.kinds():
        return False
    return True

all_numbers = list(itertools.chain(
    *[[Number(kind, i) for i in four_digit_numbers[kind]] for kind in (3,4,5,6,7,8)]
))

chains_of_length = {}
chains_of_length[1] = [Chain([n]) for n in all_numbers]

for l in (2,3,4,5,6):
    chains_of_length[l] = []
    for c1 in chains_of_length[l-1]:
        for c2 in chains_of_length[1]:
            if can_link(c1, c2):
                chains_of_length[l].append(Chain(c1.numbers + c2.numbers))
    #print(len(chains_of_length[l]), "chains of length", l)

closed_chains_of_length_6 = [
    c for c in chains_of_length[6]
    if can_link(c, c, check_kinds=False)
]

assert len(closed_chains_of_length_6) == 6  # permutations
closed_chains_of_length_6 = {c.as_set() for c in closed_chains_of_length_6}
assert len(closed_chains_of_length_6) == 1  # of the same set
chain = next(iter(closed_chains_of_length_6))
#print(chain)
print(sum(chain))
