package problems;

import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.function.Consumer;


public class Euler44 {
    /*
    Pentagon numbers
    Problem 44

    Pentagonal numbers are generated by the formula, Pn=n(3n−1)/2.
    The first ten pentagonal numbers are:

        1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

    It can be seen that P4 + P7 = 22 + 70 = 92 = P8. However, their
    difference, 70 − 22 = 48, is not pentagonal.

    Find the pair of pentagonal numbers, Pj and Pk, for which their
    sum and difference are pentagonal and D = |Pk − Pj| is minimised;
    what is the value of D?
     */
    public long solution() {
        // A best-first search of all such pairs.
        //
        // Suppose that P(n) is the largest pentagonal number we've ever seen.
        // Its nearest neighbour is P(n-1), at distance D.
        //
        //     D = P(n) - P(n-1)
        //       = n(3n-1)/2 - (n-1)(3n-4)/2
        //       = (3n² - n)/2 - (3n² - 4n - 3n + 4)/2
        //       = (3n² - n - 3n² + 4n + 3n - 4)/2
        //       = (6n - 4)/2
        //       = 3n - 2
        //
        // Its second nearest neighbour is P(n+1), at distance 3(n+1)-2 = 3n + 1.
        // The general form is: P(j) - P(i) = (j - i)(3(j + i) - 1)/2
        //
        // Note the pentagonal numbers:
        //     1, 5, 12, 22, 35, 51, ...
        // and the distances:
        //       4, 7, 10, 13, 16, ...
        // It's easy to prove by induction that they always increase by 3.
        //
        // So: which pairs (P(j), P(i)) have a distance of ≤ D?
        // We define a = (j - i) > 0.
        // Its upper bound is then:
        //
        //    (1 - 6i) + √((6i - 1)² + 24D)
        //    -----------------------------
        //               6

        long n = 100_000;    // where P(n) is the largest pentagonal number we've seen
        long D = 3 * n - 2;

        // This is a cache of values for `a`.
        // For a given `i`, it:
        //   - holds the next `a` to visit
        //   - prevents us from reevaluating the same (P(i+a), P(i)) pair
        //
        List<Integer> aNext = new ArrayList<>();
        for (int i=0; i < n; i++) { aNext.add(1); }  // Initially, it's all 1's.

        boolean foundAnything = false;
        long bestDistanceFound = Long.MAX_VALUE;

        while (true) {
            for (int i = 1; i < n; i++) {
                long P_i = pentagonal(i);

                // Calculate upper bound on a
                int a = (int)Math.ceil(((1 - 6 * i) + Math.sqrt(Math.pow(6 * i - 1, 2) + 24 * D)) / 6.0);

                for (int j = i + aNext.get(i); j < i + a; j++) {
                    long P_j = pentagonal(j);

                    if (isPentagonal(P_j + P_i) && isPentagonal(Math.abs(P_j - P_i))) {
                        if (Math.abs(P_j - P_i) < bestDistanceFound) {
                            bestDistanceFound = Math.abs(P_j - P_i);
                            foundAnything = true;
                        }
                    }
                }
                aNext.set(i, a);
            }

            if (foundAnything) {
                break;
            } else {
                // We haven't picked a large enough n.
                // Expand the search.
                n += 100_000;
                D = 3 * n - 2;
                for (int i=0; i < 100_000; i++) {
                    aNext.add(1);
                }
            }
        }
        return bestDistanceFound;
    }

    private long pentagonal(long n) {
        return n * (3 * n - 1) / 2;
    }

    private boolean isPentagonal(long n) {
        // Let's find its index:
        //     n = k(3k-1)/2
        //     2n = 3k² - k
        //     3k² - k - 2n = 0
        //     k₁,₂ = (1 ± √(1 + 24n)) / 6
        // All numbers are natural, so the only meaningful option here is:
        //     k = (1 + √(1 + 24n)) / 6
        double x = (1 + Math.sqrt(1 + 24*n))/6.0;  // should be an integer
        return (x - (long)x) < 1e-14;
    }
}
