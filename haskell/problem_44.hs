-- Problem 44 (Pentagon numbers)
-- =============================
--
-- Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2.
-- The first ten pentagonal numbers are:
--
--     1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
--
-- It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
-- However, their difference, 70 − 22 = 48, is not pentagonal.
--
-- Find the pair of pentagonal numbers, Pj and Pk, for which their
-- sum and difference are pentagonal and D = |Pk − Pj| is minimised;
-- what is the value of D?

pentagonal :: Integral a => a -> a
pentagonal n = n*(3*n - 1) `div` 2

isPentagonal :: Integral a => a -> Bool
isPentagonal n = abs(origin - (fromIntegral rounded)) < 1e-14
    where
        origin = (1 + (sqrt . fromIntegral $ (1 + 24*n))) / 6
        rounded = round origin

-- Obviously, we cannot search an infinite number of pairs of pentagonal numbers.
-- One solution is to start from pairs with minimal D, and return the first such
-- pair. That means: a best-first search of an infinite number of pairs.
--
-- I've opted for a similar, simple-to-implement solution: search all pairs
-- with distance ≤ D, for a progressively increasing D. With a bit of care,
-- it's essentially a coarser version of the best-first search, and ends up
-- checking more pairs than strictly necessary.


-- Suppose that P(n₀) is the largest pentagonal number we've seen.
-- Its nearest neighbour is P(n₀-1), at a distance od d₀ = 3n₀-2.
--
-- We're interested in all pairs (k,l) such that P(k) - P(l) ≤ d₀.
-- We define k = l + a.

-- For each l, we'll check the neighbours above it, which are closer than ≤ d₀.
neighboursToCheck :: Integral a => a -> a -> [a]
neighboursToCheck l d0 = takeWhile (\x -> x - pentagonal l <= d0) neighbours
    where
        neighbours = map (\a -> pentagonal (l + a)) [1..]


soughtDifferences :: Integral a => a -> [a]
soughtDifferences n0 = [(pk - pl) | l <- [1..n0],
                                pk <- neighboursToCheck l (3*n0 - 2),
                                let pl = pentagonal l,
                                isPentagonal (pk + pl) && isPentagonal(pk - pl)]

n0s = [10^6, 2*10^6..] :: [Int]
main = print $ (minimum . head . filter (/=[])) (map soughtDifferences n0s)
