# Problem 44 (Pentagon numbers)
# =============================
#
# Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2.
# The first ten pentagonal numbers are:
#
#     1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
#
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
# However, their difference, 70 − 22 = 48, is not pentagonal.
#
# Find the pair of pentagonal numbers, Pj and Pk, for which their
# sum and difference are pentagonal and D = |Pk − Pj| is minimised;
# what is the value of D?


def pentagonal(n: int):  # n >= 0
    return n*(3*n - 1) // 2

def is_pentagonal(n: int):
    origin = (1 + (1 + 24*n)**0.5) / 6
    rounded = round(origin)
    return origin - rounded < 1e-14 and n == pentagonal(rounded)

# Obviously, we cannot search an infinite number of pairs of pentagonal numbers.
# One solution is to start from pairs with minimal D, and return the first such
# pair. That means: a best-first search of an infinite number of pairs.
#
# But I've opted for another, simple-to-implement solution: search all pairs
# with distance ≤ D, for a progressively increasing D.

if __name__ == "__main__":

    found = []
    P = pentagonal

    # Suppose that P(n₀) is the largest pentagonal number we've seen.
    n0 = 2000000
    while True:
        # Its nearest neighbour is P(n₀-1), at a distance od d₀ = 3n₀-2.
        d0 = 3*n0 - 2

        # We're interested in all pairs (k,l) such that P(k) - P(l) ≤ d₀.
        # We define k = l + a.

        for l in range(1, n0):
            a = 1
            while P(l+a) - P(l) <= d0:
                if is_pentagonal(P(l+a) + P(l)) and is_pentagonal(P(l+a) - P(l)):
                    found.append(P(l+a) - P(l))
                a += 1

        if found:
            assert all(e > 0 for e in found)
            print(min(found))
            break
        n0 += 1000000
