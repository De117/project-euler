# Problem 44 (Pentagon numbers)
# =============================
#
# Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2.
# The first ten pentagonal numbers are:
#
#     1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
#
# It can be seen that P4 + P7 = 22 + 70 = 92 = P8.
# However, their difference, 70 − 22 = 48, is not pentagonal.
#
# Find the pair of pentagonal numbers, Pj and Pk, for which their
# sum and difference are pentagonal and D = |Pk − Pj| is minimised;
# what is the value of D?


def pentagonal(n: int):  # n >= 0
    return n*(3*n - 1) // 2

def is_pentagonal(n: int):
    origin = (1 + (1 + 24*n)**0.5) / 6
    rounded = round(origin)
    return origin - rounded < 1e-14 and n == pentagonal(rounded)

# Obviously, we cannot search an infinite number of pairs of pentagonal numbers.
# One solution is to start from pairs with minimal D, and return the first such
# pair. That means: a best-first search of an infinite number of pairs.
#
# I've opted for a similar, simple-to-implement solution: search all pairs
# with distance ≤ D, for a progressively increasing D. With a bit of care,
# it's essentially a coarser version of the best-first search, and ends up
# checking more pairs than strictly necessary.

if __name__ == "__main__":

    found = []
    P = pentagonal

    # Suppose that P(n₀) is the largest pentagonal number we've seen.
    n0 = 100000
                       # SPEEDUP:
    a_next = [1] * n0  # Starting values for `a`; we remember them to prevent
                       # double-checking any pair.
    while True:
        # Its nearest neighbour is P(n₀-1), at a distance od d₀ = 3n₀-2.
        d0 = 3*n0 - 2

        # We're interested in all pairs (k,l) such that P(k) - P(l) ≤ d₀.
        # We define k = l + a.
        # From that condition, we can calculate an upper bound on `a`:
        #
        #     a ≤ ((1 - 6l) + sqrt(36l² - 12l - 47 + 72n₀))/6
        #
        # However, it's faster to use the condition directly.

        for l in range(1, n0):
            # `a` starts from 1, or picks up where we stopped last time
            a = a_next[l]
            while P(l+a) - P(l) <= d0:
                if is_pentagonal(P(l+a) + P(l)) and is_pentagonal(P(l+a) - P(l)):
                    found.append(P(l+a) - P(l))
                a += 1
            a_next[l] = a

        if found:
            print(min(found))
            break

        n0 += 100000
        a_next += [1] * 100000
